[{"title":"Springboot 自动装配初探（Springboot 编程思想5～6章小结）","date":"2020-04-19T09:57:52.000Z","path":"2020/04/19/springboot-2/","text":"Springboot 门面注解：@SpringBootApplication @SpringBootApplication 继承了以下三个注解，并通过 @AliasFor 代理了被继承注解的一些值设置： 12345@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) @ComponentScan 用于扫描 @Component 组件 @SpringBootConfiguration 继承于 @Configuration，表示其为一个配置类 @EnableAutoConfiguration 是 springboot 实现自动化配置的核心注解，激活 自动装配机制。内部通过@Import注入了一个ImportSelector的现类 AutoConfigurationImportSelector，这个 ImportSelector 最终实现根据我们的配置，动态加载所需的bean. @SpringBootApplication 类既可以标记在 Main 类上，也可以标记在其他类上面，最后由 SpringApplication#run 引导。 由 @Bean 生成的 Bean 根据实现的地方会有差异： 在 @Configuration 下声明的 @Bean 属于 Full 模式，会有 CGLIB 增强（代理） 其他的 Bean （比如 @Component 下声明）属于 Lite 模式，不会有 CGLIB 增强 创建一个自动装配类： 1234567891011121314151617// 1. 定义一个没有 @Configuration 注解的类public class HelloConfig &#123; @Bean(\"hello\") public String hello()&#123; return \"Jihongyu\"; &#125;&#125;// 2. 定义自动配置类@Configuration@Import(HelloConfig.class)public class HelloAutoConfig &#123;&#125;// 3. resources 目录下面新建 META-INF/spring.factories 文件，配置开启自动配置类org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.cmb.config.HelloAutoConfig 自动装配一般都会和 @Conditional 一起使用，对配置进行约束。spring-boot-autoconfigure 对其又进行了扩展，构建了 13 个 Conditional 扩展注解: 12345678910111213@ConditionalOnProperty@ConditionalOnBean@ConditionalOnMissingBean@ConditionalOnClass@ConditionalOnMissingClass@ConditionalOnExpression@ConditionalOnSingleCandidate@ConditionalOnResource@ConditionalOnJndi@ConditionalOnJava@ConditionalOnWebApplication@ConditionalOnNotWebApplication@ConditionalOnCloudPlatform 这些 Conditional 也是可以按照 And、Or、Not 组合使用的，需要实现下面的抽象类: 123AllNestedConditionsAnyNestedConditionNoneNestedConditions （未完待续）","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://jihongyu.github.io/tags/springboot/"}]},{"title":"Springboot 入门杂谈（Springboot 编程思想1～4章小结）","date":"2020-04-14T15:40:03.000Z","path":"2020/04/14/springboot-1/","text":"命令行创建 Springboot 应用需要借助 Maven archetype 插件，从模板原型构建应用。 123456789mvn archetype:generate\\ -B\\ -DarchetypeGroupId=org.apache.maven.archetypes\\ -DarchetypeArtifactId=maven-archetype-quickstart\\ -DarchetypeVersion=1.1\\ -DgroupId=com.company\\ -DartifactId=project\\ -Dversion=1.0-SNAPSHOT\\ -Dpackage=com.company.project 查看依赖树 1mvn dependency:tree -Dincludes=xxx Maven spring-boot 插件在 spring-boot-starter-parent Pom 文件中。需要通过 mvn spring-boot:run 启动 sprinboot 应用需要在 pom 文件引入该 parent。 通过 mvn spring-boot:run 启动的话 Pom 文件里面不需要构建脚本。 springboot 应用打包成 jar 包需要 spring-boot-maven-plugin 插件。 编译的目录结构： BOOT-INF/classes 存放编译后的 class 文件 BOOT-INF/lib 存放依赖的 jar 包 META-INF 存放应用相关元信息，例如 MANIFEST.MF org/ 存放 springboot 相关的 class 文件 springboot 既可以打包成 Jar 包，也可以打包成 War 包运行。打成 war 包的时候需要手动在 POM 文件添加 spring-boot-loader Springboot 的 Maven 固化依赖：123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 采用导入方式：1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; Springboot 的 Web 编程范式有两大类：Servlet 和 Reactor 1234567891011&lt;!-- Servlet --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Reactor --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt; Springboot 嵌入式容器主要有 Tomcat、Jetty、Undertow、Reactor Netty 四大类。前三类既可以用于 Servlet Web，也可以用于 Reactor Web；最后一类只能用用于 Reactor Web 1234567891011121314151617181920212223&lt;!-- Tomcat --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- undertow --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jetty --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- netty Web Server --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-reactor-netty&lt;/artifactId&gt;&lt;/dependency&gt; 有实现需要学一些 Reactor Web","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://jihongyu.github.io/tags/springboot/"}]},{"title":"https deployment","date":"2020-03-15T10:29:34.000Z","path":"2020/03/15/https-deployment/","text":"TLS/SSL 介绍TLS/SSL 协议的核心：认证、密钥协商、数据加密 前向安全性：拿到私钥对历史数据进行解密。RSA 密钥协商算法和静态DH算法都不能保证前向安全性。 中间人攻击：RSA 和 DH 保证不了，需要使用 PKI 技术。 PKI 不是 TLS/SSL 技术的一部分，但是必须引入 PKI 才能保证 TLS/SSL 安全。 PKI 的核心是证 证书，通过 CA 签发的证书保证信息交换的可靠性。 申请证书的流程： 服务器准备发布 https://www.test.com 服务器实体生成公开密钥算法的一对密钥，比如一对 RSA 密钥 服务器实体生成 CSR 文件交给 CA 机构 CA 机构核实 CSR 文件 对于审核通过的 CSR 文件，CA 机构用自己的私钥对 CSR 签名附在 CSR 文件后面得到证书文件 将证书文件返回给服务实体 浏览器访问流程： 浏览器向 https://www.test.com 发出请求 服务器收到请求后将证书和 RSA 公钥发送给浏览器 浏览器根据证书中的机构信息，确定是否为 CA 签发证书，并进行验证 若验证成功，说明服务器身份是受 CA 机构认可，然后对比 RSA 公钥和证书公钥对比，判断是否是同一个服务器实体 如果验证再次成功，说明身份校验完成，接下来可以进行密钥协商 HTTPS 一般要求全站 HTTPS 策略，但是会存在 HTTPS 页面引用了非 HTTPS 元素，导致出现 混合内容 被动混合 主动混合 浏览器采取的策略一般是不一样的。","categories":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://jihongyu.github.io/categories/HTTPS/"}],"tags":[]},{"title":"HTTPS（一）加密算法","date":"2020-03-14T09:55:33.000Z","path":"2020/03/14/encrypt-algo/","text":"加密算法的四个意义隐私性：对称和非对称加密算法 完整性：摘要算法 身份确认：数字签名 不可抵赖：数字签名 Macos 中的 openssl 版本是 LibreSSL 2.8.3 随机数算法 利用计算机噪声生成随机数： 1sudo head -c 32 /dev/urandom | openssl enc -base64 伪随机数算法 Blum Blum Shub Mersenne Twister Linear congruential generator 密码学随机数生成算法 块密码算法 CTR 模式 摘要算法 流密码算法 密码学 HASH 算法HASH 算法特点： 强抗碰撞性 弱抗碰撞性 单向性 HASH 算法只要要是弱抗碰撞性和单向性 算法分类： MD5 算法：已经被证明是不安全的，理论上不具有弱抗碰撞性，不建议使用 SHA SHA-1: 已经被证明是不安全的 SHA-2: SHA-256、SHA-512、SHA-224、SHA-384 SHA-3: SHA3-256、SHA3-512、SHA3-224、SHA3-384 对称加密算法 基本思想： 密文 = E(明文，算法，密钥) 明文 = D(密文，算法，密钥) 算法类型： 块密码算法（例如：AES）：基于分组块的迭代运算 流密码算法（例如：RC4）：基于 XOR 运算 AES 迭代类型： ECB：最简单，不推荐 CBC：推荐 CTR：推荐 块密码算法的填充标准 PKCS#7。PKCS#7 可以处理 255 内的字节，PKCS#5 是他的子集，只能处理 8 个字节 对于 AES 算法，双方需要约定分组长度、迭代类型、填充方式 openssl 工具使用（加密解密均需要输入口令）： 利用 openssl 工具进行加密解密： 12345# 加密openssl enc -aes-256-cbc -salt -in file.txt -out file.encrypt -p# 解密openssl enc -d -aes-256-cbc -in file.encrypt AES 算法涉及到 salt、初始化向量、密钥、口令。其中 密钥=salt+口令 消息验证码算法由于存在中间人攻击，密码学HASH算法不能校验消息是否被篡改。 MAC 算法的种类： CBC-MAC 算法 HMAC 算法 12345# 普通HASH算法openssl dgst -sha1 file.txt# MAC 算法openssl dgst -sha224 -hmac \"123\" file.txt 非对称加密算法用途：加密解密、数字签名 RSA 算法密钥文件（包含公钥和私钥） p: 一个大质数 q: 另一个大质数 n: p*q e: 公开指数 d: 私钥=func(e,p,q) 加密 C = M^e (mod n)，解密 M = C^d (mod n) 签名 s = m^d (mod n)，验签 m = s^e (mod n) 123456789101112131415161718# 生成一个 RSA 密钥（私钥）openssl genrsa 2048# 生成一个 RSA 私钥，并导出公钥openssl genrsa -out rsa_pri.pem 2048openssl rsa -in rsa_pri.pem -pubout -out rsa_pub.pem# 校验密钥是否正确openssl rsa -in rsa_pri.pem -check -nooutopenssl rsa -pubin -in rsa_pub.pem -text# 加解密文件（默认采用PKCS#1 v1.5填充 -pkcs，也可以手动指定PKCS#1OAEP填充 -oaep）openssl rsautl -encrypt -pubin -inkey rsa_pub.pem -in file.txt -out file.encryptopenssl rsautl -decrypt -inkey rsa_pri.pem -in file.encrypt# 数字签名，对摘要签名openssl dgst -sha256 -sign rsa_pri.pem -out file.sign file.txtopenssl dgst -sha256 -verify rsa_pub.pem -signature file.sign file.txt ECC 算法加密： 123456789101112131415161718192021222324252627# 罗列自带的命名曲线openssl ecparam -list_curves# 生成一组椭圆曲线密钥，并显示出参数openssl ecparam -name secp256k1 -out secp256k1.pemopenssl ecparam -in secp256k1.pem -text -param_enc explicit## output:Field Type: prime-fieldPrime: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:fe:ff: ff:fc:2fA: 0B: 7 (0x7)Generator (uncompressed): 04:79:be:66:7e:f9:dc:bb:ac:55:a0:62:95:ce:87: 0b:07:02:9b:fc:db:2d:ce:28:d9:59:f2:81:5b:16: f8:17:98:48:3a:da:77:26:a3:c4:65:5d:a4:fb:fc: 0e:11:08:a8:fd:17:b4:48:a6:85:54:19:9c:47:d0: 8f:fb:10:d4:b8Order: 00:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff: ff:fe:ba:ae:dc:e6:af:48:a0:3b:bf:d2:5e:8c:d0: 36:41:41Cofactor: 1 (0x1) A、B 椭圆曲线参数，P 大质数，Generator G点，n 椭圆曲线的阶，Cofactor 椭圆曲线所有点除以 n 数字签名算法 ECDSA： 1234openssl ecparam -name secp256k1 -genkey -out ecdsa_pri.pemopenssl ec -in ecdsa_pri.pem -pubout -out ecdsa_pub.pemopenssl dgst -sha256 -sign ecdsa_pri.pem -out file.sign file.txtopenssl dgst -sha256 -verify ecdsa_pub.pem -signature file.sign file.txt 密钥口令：方便记忆的人造简单密钥 密钥：计算机生成的随机数 DH 密钥协商算法由通信双方 A 和 B 一起协商生成一个会话密钥（思想比算法更重要）","categories":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://jihongyu.github.io/categories/HTTPS/"}],"tags":[]},{"title":"python cookbook","date":"2017-06-09T07:40:07.000Z","path":"2017/06/09/python-cookbook/","text":"Python 进阶必备 Chapter 1：数据结构与算法本章介绍了 Python 内置数据类型的使用技巧与方法。由于 Python 是脚本语言，所以在 Python 编码的过程中，我们应当使用其内置的方法（built-in）。因为这些方法大多数是由 C 实现的，有极高的效率。本章围绕着 Python 的内置内省，主要介绍了三个主要的内置模块：collections、itertools、operator。 collections：该模块基于内置类型（dict、list、set和tuple）实现了一些更高级的数据结构类型。 itertools：该模块实现了一组快速的、内存高效的“迭代器代数”工具。 operator：该模块提供一组高效的与内置运算符对应的函数。这些函数包括执行对象比较、逻辑操作、数学运算和序列操作的类别。 此外，本章好介绍了一些有效的内置函数。有效的使用这些函数可以很好的提高编码和程序执行的效率。这些函数包括但不限于：slice、sorted、filter、compress、any/all等等。 所以，一般对于 Python 程序设计，若使用相同的算法，则程序越短效率越高。 Chapter 2：字符串和文本本章主要涉及字符串和文本的处理。由于 Python 内置的函数和方法，使得对文本的处理极大地便利化。Python 的文本处理方法主要分为两大块：基于 字符串 的处理和基于 正则表达式 的处理。由于生产任务的需要，通常将文本的处理分为以下几类，同时也罗列了相关的只要函数和方法： 切分：re.split、str.split 匹配： 查找：str.find、str.startwith、str.endwith、正则匹配 替换：str.replace、str.transform、re.sub 删除：str.lstrip/rstrip/strip 格式化：str.ljust/rjust/center、str.format、string 模板、C风格格式化 合并字符串：str.join、运算符 加号 正则匹配： 组模式 贪婪匹配 多行匹配 本章介绍了基本正则表达式使用方法，可以适用于许多场景，但是为了更加高效的使用，我们还需要深入的学习，参见《Python 核心编程（第三版）》第一章的内容。 Chapter 3：数字、日期和时间本章介绍了 Python 处理数值数据和时间数据的方法。进行精确计数（金融）的应用场景应当使用 decimal 模块。2、8、16进制字符串生成函数：bin、oct、hex。检测 INF、NaN 函数：math.isinf和math.isnan。时间处理主要涉及内置模块 datetime 和第三方模块 dateutil。 Python 本身的数据处理能力较弱，不建议使用内置 Python 方法进行数据处理。我们应当是用 Numpy、Scipy 等第三方数学库进行科学计算。 Chapter 4：迭代器和生成器迭代协议Python 支持在容器（container）上进行迭代。需要为容器对象定义一种方法来提供迭代支持： container.__iter__() 返回一个迭代器对象。该对象需要支持 迭代器协议。 迭代器对象本身需要支持以下两种方法，它们一起形成迭代器协议： iterator.__iter__()返回迭代器对象本身。这是允许容器和迭代器与for和in语句一起使用的。该方法对应于Python / C API中Python对象的类型结构的 tp_iter slot。 iterator.__next__()从容器返回下一个元素。如果没有下一元素，则会引发 StopIteration 异常。该方法对应于Python / C API中Python对象的类型结构的 tp_iternext slot。 Python 的生成器（generator）提供了实现迭代器协议的便捷方式。 如果容器对象的 __iter__() 方法被实现为生成器，它将自动返回一个提供 __iter __() 和 __next __() 方法的迭代器对象（技术上是一个生成器对象）。","categories":[],"tags":[{"name":"读书","slug":"读书","permalink":"https://jihongyu.github.io/tags/读书/"},{"name":"Python","slug":"Python","permalink":"https://jihongyu.github.io/tags/Python/"}]},{"title":"菜鸟的自我修养","date":"2017-05-24T01:13:38.000Z","path":"2017/05/24/naivebird-learning/","text":"菜鸟程序员的学习和进阶之路上，有太多的艰难险险阻，CS 方向上的各种大坑让人看起来唏嘘不已。同时由于码农界的新技术层出不穷，要想掌握全部也不是可能的，所以理解 CS 的思想精髓是十分有必要的。下面就理论篇、语言篇、工具篇和应用篇分别介绍小白的成长之路。 理论篇对于程序员的最主要的理论知识其实就是操作系统和算法理论。作为非科班出身的码农，能够在有限的时间能掌握这两部分知识是难能可贵的。当然，如果有时间能够把计算机专业的专业课程都学一遍那是最好的呢，不过这估计是很难的。就像通信专业的 DSP 课程，听了课都不一定听得懂:-P。当然，作为通信的学生，通信网络这一块知识是不能丢掉的哦。还有一些跟写代码相关的理论知识也是需要掌握理解的。 操作系统操作系统需要掌握的基本知识包括：进程、线程；任务调度；系统调用；I/O 等方面的内容。 参考书籍： 《现代操作系统》 《linux内核设计与实现》 算法理论算法方面需要学习算法设计分析技术：包括动态规划、贪心算法等等。同时也需要掌握相关数据结构及其对应算法的知识：主要包括线性结构、链式结构、树形结构、图结构、散列结构等。算法实现需要学习的包括：排序算法、二叉树算法、平衡二叉树算法、堆算法、图算法。 参考书籍： 《算法导论》 《数据结构 C++》邓俊辉 《算法》（Java 版本） 《编程珠玑》 网络协议网络协议是一门计算机互联通信的技术，不过对于程序员来说只需要了解其工作原理就行了。主要要学习的内容是：TCP/IP 协议簇的基本架构，每层协议的具体功能；TCP 协议的内容；IP 协议的内容；HTTP 协议的内容（稍微了解即可）。 参考书籍： 《TCP/IP 协议簇》 《TCP/IP 详解卷1》 《图解TCP/IP》（入门） 设计模式教你怎样构建代码。5种设计原则，23种设计方法，虽然东西很死很抽象，不过代码写的越多就会理解越深。面试的时候一般很喜欢考一些基本常见的设计模式：单例模式，观察者模式等等。 参考书籍： 《大话设计模式》 语言篇语言是人类交流的载体，而计算机语言便是人机之间、码农之间交流的载体。现在主流的三大系统语言包括：C/C++，Java，C#。对于不搞 Windows 的，C# 可以被抛弃。程序语言的学习一般主张一门系统语言加一门小脚本语言。对于我们还没有进入工作岗位，面向任何语言的岗位的工作都是有可能，甚至有时候工作还是全栈的，啥子活都要做。所以一门系统语言加一门小脚本语言用来培养语感，以适应未来不同的变化。 C/C++这玩意儿神坑。说多了都是泪。由于 C++11/14 又加了好多新标准，哎。。 参考书籍： 《C++ primer》 《Effective C++》 《More Effective C++》 《深度探索 C++ 对象模型》 《C++ 标准库》 《深入理解C++11 : C++ 11新特性解析与应用》 JavaJava 不错，严格规范。可后台亦可移动端。但是我也没有深入学习过，只是了解后期需要学习 SSH 。 参考书籍： 《Java 编程思想》 《深入理解 Java 虚拟机》 Python人生苦短，我用 Python。Python 作为代码界的万金油一直被人们所喜爱。算法、科学计算、服务端开发等等都离不开它的身影。Python 由于入门难度不搞，随便一本技术书都可以搞定。但是 Python 的精髓是在灵活的使用代码库，所以流传着这样一句话：代码越短效率越高。在学习 Python 的过程中，最基本的是要学习内置模块。 参考书籍： 《Python 核心编程》 《Python Cookbook》（进阶必备） 《Python 源码剖析》 其他语言在构建程序系统中还有很多其他的语言可以选择，但是鉴于笔者了解不多，不能给出参考意见。比如大名鼎鼎的 PHP，还有前端的各类设计语言。不过一些在服务端使用的语言还是很不错的，可以用于尝试着学习，比如 Scala，Erlang，Golang 等等。这些语言各有所长，在相应领域内都有这不错的地位。 Scala：基于 Java 虚拟机的语言，用于 Spark； Erlang：通用并发语言，最早用于电信业务； Golang：用于高并发场景。 工具篇工具，既是轮子。轮子有小，也有大。小轮子那些程序语言的底层公用模块，或者是第三方库，这在学习程序语言的时候就应该相应的学习。这里我们介绍的是大轮子，大轮子是那些大规模的程序系统或者框架，用于支持我们的程序开发。这些程序或者框架包括存储、Web 开发、分布式等方面的内容。但是最重要的、最大的程序框架，是操作系统本身。一切计算过程，以操作系统为运行平台。所以，对操作系统的认识也是至关重要的。 MySQL数据库的使用是程序需要掌握的必备知识。虽然 MySQL 被 Oracle 收购了，但还是有社区版本可以使用的。数据库需要掌握的基本知识是数据库表项的增删查改，此外，有时间可以看看数据库的优化工作等等。 参考书籍： 《MySQL 必知必会》 《SQL 入门经典》 Linux大多数服务器上跑的操作系统都是 Unix/Linux，所以对于熟悉和使用 Linux 操作系统也是必备的知识。 参考书籍： 《鸟哥的Linux私房菜：基础学习篇》 《UNIX/Linux 系统管理技术手册》（当字典查阅就行了） RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。这个只需要了解它的使用就行了 参考书籍： （艹，看了本入门小书，忘了名字了） 《Redis 设计与实现》（将要看）","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://jihongyu.github.io/tags/学习/"},{"name":"进阶","slug":"进阶","permalink":"https://jihongyu.github.io/tags/进阶/"}]},{"title":"CentOS 使用指导","date":"2017-05-11T12:29:08.000Z","path":"2017/05/11/centos-tutorial/","text":"","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://jihongyu.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://jihongyu.github.io/tags/操作系统/"}]},{"title":"具体数学","date":"2017-05-03T16:13:03.000Z","path":"2017/05/04/concrete-mathematics/","text":"《具体数学》这本书啊，从我研究生入学之前就知道其重要的地位。但是限于自己能力有限，断断续续地看完了3章内容；研究生的一些课程（组合数学，抽象代数之类）里面有涉及到其中的一些知识。而今临近毕业，自己还是想将其中的内容看完，一是完成自己未实现的小小读书目标，二是实现整理下所学的数学知识，三是也是最宏伟的目标是为以后学习 TAOCP 打下坚实的基础。 我的学习计划分为三部分：浏览学习书本知识；刷完基本习题；认真做好学习笔记。学习期限是一个半月。 Try my best.","categories":[],"tags":[]},{"title":"《Unix 编程艺术》内容整理","date":"2017-04-18T12:49:20.000Z","path":"2017/04/18/the-art-of-unix-programming/","text":"Unix/Linux 神坑，追求简约精致的系统设计。 Part 1：介绍Unix 哲学 17 个 基本原则： 模块原则：使用简洁的接口拼合简单的部件； 清晰原则：清晰胜于投机； 组合原则：设计师考虑拼接组合； 分离原则：策略同机制分开，接口同引擎分开； 简洁原则：设计要简洁，复杂度能低则低； 吝啬原则：不要编写庞大的程序； 透明性原则：设计要可见，用于审查和调试； 健壮原则：健壮源于透明和简洁； 表示原则：把知识叠入数据以求逻辑质朴而健壮； 通俗原则：接口设计避免标新立异； 缄默原则：如果一个程序没什么好说的，就沉默； 补救原则：出现异常时，马上退出并给出足够错误信息； 经济原则：宁花机器一分，不花程序员一秒； 优化原则：雕琢前先要有原型，跑之前先学会走； 多样原则：决不相信所谓“不二法门”的断言； 扩展原则：设计着眼未来，未来总比预想来得快。 Unix 哲学总结：KISS 原则。（Keep it simple, stupid!） Unix 惨痛的历史经验告诉我们：开源比商业更重要，分享比利益更重要。 Unix 优势：高度可移植性、轻松编程。 Part 2：设计模块性：保持清晰和简洁模块化的本质就是对软件设计进行建模，在完整功能的基础上保证模块间的 正交性 和 紧凑性。 模块设计的粒度也是有考究的，不能太大或者太小。太大导致模块更容易出 Bug，不利于问题定位；太小会导致模块的正交性变差，也容易增加软件设计的 Bug。 重构（refactoring）：改编代码的结构和组织，而不改变其外在行为。 模块设计的关键就是 API 的设计。 SPOT 原则：对象的唯一性。这里的对象表示代码块或者是数据。 软件设计的层次模型：自顶向下还是自底向上。Unix 程序员偏向于自底向上。 Unix 主张非面向对象的（OO），Unix 主张简单、直观的薄胶合层，所以不提倡庞大而繁杂的面向对象思想。复杂就意味着 BUG。 数据文本化的好处： 直观透明，具有可读性 数据扩展方便 文本具有通用性，方便程序协作（管道的使用） 基于文本协议的几个重要的计算机技术：XML-RPC、SOAP、Jabber 软件系统中的两个重要品质： 透明性：使用者只需花少量代价便可以了解或是预测软件的行为、状态 可显性：使用者可以容易了解到原件系统的实现方式、原理等 terminfo 数据库 Part 3：工具Part 4：社群","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://jihongyu.github.io/tags/Linux/"},{"name":"读书","slug":"读书","permalink":"https://jihongyu.github.io/tags/读书/"}]},{"title":"计算复杂性","date":"2017-04-08T02:24:18.000Z","path":"2017/04/08/compute-complexity/","text":"计算复杂性理论基础介绍，看看就行，不需要作深入研究。 第一章：第二章：第三章：第四章：NP 问题与计算可行性归约的定义（抽象）： 对于全集 $\\mathrm N$ 给定两个子集$\\mathrm A$和$\\mathrm B$，以及一个由 $\\mathrm N$ 映射到 $\\mathrm N$ 的并满足复合封闭性的函数集合 $F$，如果满足[\\exists f \\in F.~\\forall x \\in \\mathrm N.~x\\in \\mathrm A \\Longleftrightarrow f(x) \\in \\mathrm B]记作 $\\mathrm A \\le_F \\mathrm B$ 归约等价性：如果 $X\\le_PY~\\land~Y\\le_P X~\\Longleftrightarrow~X\\equiv_P Y$ 归约的目的是对问题的分类： 设计算法。如果 $X\\le_P Y$ 并且 $Y$ 是在多项式时间内可解决的，这 $X$ 也可以在多项式时间内解决； 建立不可计算性。如果 $X\\le_P Y$ 并且 $X$ 不能在多项式时间内解决，这 $Y$ 也不能在多项式时间内解决。 归约的基本策略： 简单的等式关系推到。图论中独立集问题与点覆盖问题的归约等价性。 从特殊情况推广到一般情况。点覆盖归约到集合覆盖问题。 构造方法。3-SAT问题归约到独立集问题。 证明归约问题一般使用构造证明法，对于归约问题$X\\le_P Y$，我们需要构造一个关于$X$和$Y$的桥梁$P$，我们需要证明在$P$下，关于$X的解和关于$Y$的解是等价的。 判定问题，搜索问题。 判定问题$A$的定义：对于字符串全集$\\Omega$，以及其子集$X\\subset \\Omega$，这对于任意一个实例$s\\in \\Omega$，有：[A(s)=\\mathrm{yes}\\Longleftrightarrow s \\in X] 判定问题是多项式可求解的是指：对于任意的输入$s$，算法的运行最多在$|s|$的多项式步骤上完成。 验证算法：一种特殊的判定问题。 判定问题归类： P. 有多项式时间求解的判定问题； NP. 存在多项式时间验证算法的判定问题； EXP. 存在指数时间求解的判定问题 证明：$\\mathrm P \\subseteq \\mathrm{NP}$ 和 $\\mathrm{NP} \\subseteq \\mathrm{EXP}$ 多项式转换、多项式归约 不是很懂 NPC.定义：对于一个NP问题Y，每个NP问题X都满足$X\\le_p Y$。 第一个NPC问题：电路满足问题 证明一个问题 Y（注意是判定问题）是NPC的： 证明Y是NP的 选择一个已知的NPC问题X 证明归约性$X\\le_p Y$ 6类基本的NPC问题： Packing problems: SET-PACKING, INDEPENDENT SET. Covering problems: SET-COVER, VERTEX-COVER. Constraint satisfaction problems: SAT, 3-SAT. Sequencing problems: HAMILTONIAN-CYCLE, TSP. Partitioning problems: 3D-MATCHING 3-COLOR. Numerical problems: SUBSET-SUM, KNAPSACK. (To be continued.)","categories":[],"tags":[]},{"title":"latex_tutorial","date":"2017-01-04T00:57:19.000Z","path":"2017/01/04/latex-tutorial/","text":"前言Latex 这个东西有什么好说的呢。。 等有问题了再来总结","categories":[],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://jihongyu.github.io/tags/Latex/"}]},{"title":"git_tutorial","date":"2017-01-04T00:56:49.000Z","path":"2017/01/04/git-tutorial/","text":"Git 是牛逼的软件开发版本控制系统，学习它是大大的好 配置 Git 与 Github 连接1.生成 SSH Key1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 2.把 SSH Key 加入 SSH 代理（可选）12eval $(ssh-agent -s) #保证 ssh-agent 处于运行中ssh-add ~/.ssh/id_rsa 3.将 .ssh/id_rsa.pub 文件内的内容粘贴至个人Github配置中去。 （Settings -&gt; SSH and GPG keys -&gt; New SSH key） 4.连接测试1ssh -T your_email@example.com Git 基本术语工作区：当前项目工作目录下，除了 .git 文件夹下的所有内容。 版本库：.git 文件下的所有东西，里面包含了暂存区和分支区 暂存区：虚拟工作区，跟踪工作区文件的变化。由 index 文件维护。 分支区：保存分支信息的地方，暂存区的内容经过 commit 后会产生新的分支。HEAD 一般指向最新commit的引用，可以通过版本回退的方式改变HEAD的指向 基本使用方法git init: 将当前目录设置为 git 仓库。它会生成一个 .git 文件夹。 git add: 添加文件到暂存区。 git commit: 将暂存区文件提交到本地仓库。 git diff: 对比文件。只能对比文本文件，二进制文件就无能为力了。 git status: 查看仓库状态。 git log: 查看历史记录。 git reset: 版本退回。 git checkout: 从暂存区或者分支中迁出文件。 参考文献Git使用教程Git 菜鸟变大神 （三） 工作区、暂存区、版本库之间的关系案例","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://jihongyu.github.io/tags/git/"}]},{"title":"Community Detection and Mining in Social Media","date":"2016-12-24T04:04:43.000Z","path":"2016/12/24/Community-Detection-and-Mining-in-Social-Media/","text":"前言Community Detection and Mining in Social Media一书中详细的社会网络的计算分析问题。该书主要讲述了社会网络的社团发现问题。作者总结了现有的社团发现算法，并将其总结抽象成了4个方面： 基于节点的社团结构； 基于群组的社团结构； 基于网络的社团结构； 基于层次的社团结构。 同时，作者分析了混杂网络的社团发现问题。作者认为，随着社会网络的复杂性和多样性，在研究中很难将社会网等效地简化为简单同质网络，所以研究混杂网络下的社团发现是很有必要的。在作者的观点中，混杂网络包含两个方面：多维网络 和 多模网络。 多维网络是指网络中的边（或关系）存在着不同的物理含义，同时节点对间允许存在多条不同的边关系。它的等价定义就是多层复杂网络（Multiplex Networks）。 多模网络是指网络的节点存在不同的物理含义。它的等价定义就是（Heterogeneous Networks）。 社团发现算法以节点为中心的社团发现该类方法要求一个团体中的每个节点都要具备一定的属性。根据属性的松弛条件可以依次归纳为： 完全相互关系：K-Clique 若完全相互关系：CMP(Clique Percolation Method) 可达性：巨分支 以群组为中心的社团发现该类方法是将一个群组内的所有链接（link）作为整体考虑。只要这个整体满足一定的性质，便可以将其划分为一个社团。一个例子就是通过边密度来作为社团的依据。 以网络为中心的社团发现该类方法考虑网络的整体拓扑结构。一般是利用图的邻接矩阵或者是其他矩阵计算图的划分问题。主流的算法包括： 顶点相似度模型 隐含空间模型 块近似模型 谱聚类 谱模块度最大化 以层次为中心的社团发现根据网络拓扑构建一个层次性的社团结构。构建方法有分裂法和聚合法。 社团评价指标基于 Ground Truth：Normalized Mutual Information 自洽的评价准则：模块度，划分密度 混杂网络问题从宏观上来看，社会媒体网络通常是混杂的，它包含着各种类型的关系和节点。从大的类型可以将其分为 多维网络 和 多模网络： 多维网络（Multi-dimensional Networks）：也称之为 多层网络（Multiplex Networks, Multilayer Networks, Multislice Networks） 多模网络（Multi-mode Networks）：也称之为 异质网络（Heterogeneous Networks） 多维网络的社团发现算法本书提到的基于多为网络的社团发现算法的一个潜在假设是网络的每个维度都具有潜在的相似的社团结构，否则挖掘的社团结果没有意义。 多为网络的社团发现算法是基于普通网络的社团发现算法，只是在一些地方将数据信息进行了融合集成，根据融合的不同可以分为一以下4个层次： 网络集成 效用集成 特征集成 划分集成 网络集成将多维网络简单的融合成加权的一维网络，然后对该网络做社团发现。 效用集成将效用矩阵求和相加，然后处理。 特征集成分别利用效用矩阵求出特征向量，然后组合成新的特征。 划分集成每一维网络分别得到一个划分结果，然后将划分结果进行组合。 多模网络的社团发现算法(To be continued.)","categories":[],"tags":[{"name":"复杂网络","slug":"复杂网络","permalink":"https://jihongyu.github.io/tags/复杂网络/"}]},{"title":"APS Journals","date":"2016-12-22T14:45:53.000Z","path":"2016/12/22/aps-journals/","text":"APS JOURNALS 介绍前言由于科研的需要接触到了美国物理学会的各类名刊。其刊物名字种类繁多，遂总结如下。 英文参考来自 APS JOURNALS 官网。 Physical Review LettersPhysical Review Letters (PRL) is the premier APS journal for current research, providing rapid publication of short reports of important fundamental research in all fields of physics. PRL provides its diverse readership with weekly coverage of major advances in physics and cross-disciplinary developments. Physical Review XPhysical Review X (PRX) is an online-only, fully open access, peer-reviewed journal that aims to publish, as timely as possible, exceptional original research papers from all areas of pure, applied, and interdisciplinary physics. Reviews of Modern PhysicsReviews of Modern Physics (RMP) brings the broad fundamental physics literature in established topical areas together and places it within the context of current trends in research and applications. Its in-depth review articles and shorter Colloquia serve students, engineers, and physics researchers in a range of fields. Physical Review A covering atomic, molecular, and optical physics and quantum information 涉及原子、分子和光学物理学和量子信息 Physical Review A (PRA) provides a dependable resource of worldwide developments in the rapidly evolving area of atomic, molecular, and optical physics, as well as quantum information. Physical Review B covering condensed matter and materials physics 涉及凝聚态物理和物质物理 Physical Review B (PRB) is the largest and most comprehensive international journal specializing in condensed matter and materials physics phenomena. Physical Review C covering nuclear physics 核物理方向 Physical Review C (PRC) publishes leading research in all areas of experimental and theoretical nuclear physics. Physical Review D covering particles, fields, gravitation, and cosmology 涉及粒子、场、引力以及宇宙学 Physical Review D (PRD) publishes leading research in elementary particle physics, field theory, gravitation, and cosmology. Physical Review E covering statistical, nonlinear, biological, and soft matter physics 涉及统计、非线性、生物以及软物理问题 Physical Review E (PRE), broad and interdisciplinary in scope, focuses on collective phenomena of many-body systems, with statistical physics and nonlinear dynamics as the central themes of the journal.","categories":[],"tags":[{"name":"学术","slug":"学术","permalink":"https://jihongyu.github.io/tags/学术/"}]},{"title":"msys2","date":"2016-12-20T04:09:06.000Z","path":"2016/12/20/msys2/","text":"前言在 Windows 平台下编译使用 Unix-Like 的程序，MSYS2 是一个不错的工具平台。 在 Windows 平台下编译 Unix-Like 程序，常见的方法有两种：MinGW 和 Cygwin。 Cygwin主要用于在 Windows 下开发 Linux 环境软件，兼容性好，但是速度慢，编译的软件不适用于在 Windows 平台作生成使用。 MinGW在 Windows 下编译 Linux 程序，兼容性虽然没有 Cygwin 好，但是程序运行效率高，是在 Windows 下运行 Linux 程序的主要选择。但是 MinGw 有个缺点就是下载速度慢，安装配置麻烦，这是很不方便的。 MSYS2MSYS2 是一个基于 Cygwin 和 MinGw-w64的 MSYS 升级版工具，目的是提供与 Unix-Like 类似的环境系统。 MSYS2 提供一个 Arch Linux 的包管理系统 Pacman，可以很方便的管理 MSYS2 的各种软件包。 MSYS2 的使用需求需要在 Windows 环境下编译 Unix/Linux 代码，使用其可执行程序。统一管理 Unix/Linux 类软件，因为有些软件涉及到大量的环境变量和配置文件等东西，这类软件在 Windows 下面做的并不是很好，比如 git 。 MSYS2 的使用须知MSYS2 有三个启动器：msys2、mingw32、mingw64，分别对应三种不同的编译环境。 （未完待续）","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://jihongyu.github.io/tags/工具/"}]},{"title":"Combinatorial Mathematics","date":"2016-12-06T15:36:39.000Z","path":"2016/12/06/Combinatorial-Mathematics/","text":"前言课程链接 OEIS数据库 Chapter 1~2: 组合数学初步基本计算规则（注意事件的独立性）： 加法规则：考虑事件的成分（类别） 乘法规则：考虑事件的步骤 减法法则：考虑事件的对立面 除法法则：等价类（重复类）的划分 组合问题的经典模型1：小球选取模型描述：将 $n$ 个 不同 的小球选择 $r$ 个放入 $r$ 个盒子中，存在多少种不同的选取方法。从这个问题我们可以引入组合数学的两个基本的计数问题。 排列（Permutation）：盒子有编号，取出的小球有顺序 基于乘法规则递推关系式：$P(n,r)=n\\times P(n-1,r-1)$ 基于加法规则的递推关系式：$P(n,r)=P(n-1,r)+P(n-1,r-1)$ 组合（Combination）：盒子无编号，取出的小球无顺序重要公式： $C(n,l)\\times C(l,r)=C(n,r)\\times C(n-r,l-r)$ 组合问题的经典模型2：格路模型描述：从坐标(0,0)点到(m,n)点的所有格路径的条数是多少。 解答：$C(m+n,m)$ 杨辉三角，二项式定理 Chu-Vandermonde 等式[ \\dbinom{m+n}{r} = \\sum_{k=0}^{r} \\dbinom{m}{k}\\cdot\\dbinom{n}{r-k}] 各种排列圆排列：从 $n$ 个 不同 的元素取出 $r$ 个构成一个圈，一共有多少种取法。 解答：将圆排列转换成线排列，再去掉重复的计数（除法规则）。答案：$P(n,r)/r$ 项链排列：圆排列的基础上考虑镜像对称。 解答：$P(n,r)/2r$ 多重排列元素的个数是有限的，元素是可以重复选取的（多项式定理）。 全排列定义：若干元素，$r_1$个 1，$r_2$个 2···$r_t$个 t，其元素个数值和为 $n$，则其全排列数记为：[ P(n;r_1,r_2,…,r_t)=\\frac{n!}{r_1!r_2!…r_t!} \\qquad \\sum_{i=1}^t r_i = n] 其思路运用了除法规则，类比于圆排列。 排列组合计算技巧：相邻问题用捆绑发；分区域问题用隔板法 可重组合$n$ 个不通用的元素中可重复地选取 $r$ 个元素，则取法数有 $C’(n,r)=C(n+r-1,r)$ 证明方法： 方法1：基于序列相加的组合证明。（基本方法） 方法2：转换问题：在 $n$ 个不同的元素去 $r$ 个进行组合，等价于吧 $r$ 个元素分成 $n$ 个区域。（高级抽象） 不相邻组合$n$ 个不通用的元素中不相邻地选取 $r$ 个元素，则取法数有 $C’’(n,r)=C(n-r+1,r)$ 基本排列组合简单模型小结 类型 例子 顺序要求 重复要求 计数 无重组合 n个球取r个 No No $C(n,r)$ 无重排列 n个球取r个 Yes No $P(n,r)$ 可重组合 线性方程求解个数 No Yes $C(n+r-1,r)$ 可重排列 单词组合 Yes Yes $n^r$ 多重全组合 $r_1$个a，$r_2$个b组成的n位串 Yes Yes $\\frac{n!}{r_1!r_2!}$ 注意：可重的意思是元素是无限的，多重的意思是元素的个数是有限的（但不限于1）。 全排列生成算法原始递归法由 n-1 个元素排列生成 n 个元素的排列 字典序法基于字典序生成全排列，其思想是序列前缀尽量不变，只是微微增大后缀部分。算法步骤如下： 从右至左扫描序列，找出序列的第一个下降点 在该下降点的右边找出一个最小变化点 交换这两个元素，形成下一个排列 SJT(Steinhaus–Johnson–Trotter)算法局部移动。 设[a1,a2 … aN] 每一项都有向左或向右两个移动方向。 初始化所有移动方向向左； 如果移动方向的值比自己小，就可移动，比如 2 &lt;3, 每个数字前箭头的方向表示该数字的移动方向，3可以移动，2和1不可移动； 移动最大的可以动项，在上面例子中就是数字3； 将所有比移动项大的项方向反转，重复第三步，直到不能移动为止。 Stirling数估计[ n! \\sim \\sqrt{2\\pi n}(\\frac{n}{e})^n] Chapter 3: 母函数（生成函数）初步母函数是形式幂级数，是一种计数工具其形式为：[ G(x) = c_0 + c_1x + c_2x^2 + c_3x^3 + …] 母函数的一项 $cx_k$：幂级数 $k$ 表示实际 对象个数 的抽象；系数 $c$：表示在该 对象个数 下的计数。 母函数实际上蕴含着一种映射关系 母函数运算中蕴含着乘法规则和加法规则。 母函数就是一系列用来展示一串数字序列的挂衣架。 砝码称重问题1g, 2g, 3g, 4g 砝码各一个，问一共有多少种称重方式。 整数拆分问题有序拆分：$C(n-1,r-1)$ 无序拆分：把一个整数拆分成若干部分之和，相当于将 $n$ 个 无区别 的小球放入 $r$ 个 无区别 的盒子里。 注意无序拆分与可重组合模型的区别：无需拆分中的基本元素是 对象的个数，而可重组合模型是 不同类别对象的个数。举个例子：在取小球模型中，整数拆分是将小球放入不同的盒子里；而可重模型是将不同颜色的小球放入同一个盒子里。 模式方法 Birch and Swinnerton-Dyer 猜想 Ferrers 图像 整数拆分的形象几何表示。 性质： 整数拆分中，最大数是 $k$ 和 $k$ 个数之和的拆分数是相等的。 若整数 $n$ 能拆分成若干个奇数之和，则其 Ferrers 图像是自共轭的。 母函数与递推关系（差分方程） 汉诺塔问题 求 $n$ 位十进制数中出现偶数个5的数的个数 求解： 令 $a_n$ 表示 $n$位十进制数中偶数个5的数的个数 令 $b_n$ 表示 $n$位十进制数中奇数个5的数的个数[ a_n=9 \\cdot a_{n-1}+b_{n-1} b_n=9 \\cdot b_{n-1}+a_{n-1}] 母函数小结： 母函数建立了一个序列与递推关系的桥梁。 Chapter 4: 线性常系数递推关系Fibonacci 递推关系：[ F_n = F_{n-1}+F_{n-2}] Fibonacci 恒等关系式：[ F_1^2+F_2^1+···+F_n^2=F_nF_{n=1}][ F_1+F_2+···+F_n=F_{n+2}-1][ F_1+F_3+···+F_{2n-1}=F_{2n}][ F_{n-1}F_{n+1} -F_n^2= (-1)^n] Fibonacci 通项直接计算方法： 母函数法 Fibonacci优选法 线性常系数其次递推关系递推多项式产生特征多项式 特征多项式根的情况： 无重根 有重根 无实根 Chapter 4: 神奇的序列Catalan数递推关系： [C(n) = \\sum_{k=1}^n C(k-1) \\cdot C(n-k)] 解析表达式：[C(n)=\\frac{1}{n+1} \\dbinom{2n}{n}]栈混洗模型 二叉树个数计数问题 正多边形划分为不重叠的三角形计数问题 Dyck Path Dyck Word （括号匹配）","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://jihongyu.github.io/tags/组合数学/"}]},{"title":"Use Sublime 3","date":"2016-12-04T11:53:59.000Z","path":"2016/12/04/Use-Sublime-3/","text":"前言Sublime Text 3 文本处理神器。 快捷键篇Ctrl+D 选词 Ctrl+L 选中整行 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 Ctrl+/ 注释整行或选中内容 Ctrl+K Ctrl+K+U 改为大写 Ctrl+K+L 改为小写 未完待遇，先记住几个常用的 插件篇Package Control 安装通过 ctrl + ` 或者 View &gt; Show Console ` 菜单打开命令控制台输入： 1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) Markdown 支持markdown 写作插件：MarkdownEditing MarkDown 预览插件：OmniMarkupPreviewer（支持 Tex 公式） Python 支持SublimeCodeIntel：代码补全，好像是个通用语言查件 中文编码友好支持GBK Support","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://jihongyu.github.io/tags/工具/"}]},{"title":"Thinking in Java (2). 面向对象","date":"2016-11-17T15:02:08.000Z","path":"2016/11/17/thinking-in-java-2/","text":"前言Java 入门第二弹，面向对象。这里介绍 Java 中 OOP 的关键点和难点。 正文Java 中的包的概念和 C++ 中的名字空间的概念是类似的。Java 的包有层次概念，可以很好的与文件目录结构很好的协作起来，而 C++ 的名字空间是一个平面的概念。Java 在每个 .java 文件里面只能定义一个包，相当于该文件的保护伞。 一个 .java 文件只能定义一个 public class，每一个 class 都会生成对应一个 .class 文件。 (To be continued… )","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jihongyu.github.io/tags/Java/"},{"name":"入门","slug":"入门","permalink":"https://jihongyu.github.io/tags/入门/"}]},{"title":"Thinking in Java (1). 面向过程","date":"2016-11-15T15:03:03.000Z","path":"2016/11/15/thinking-in-java-1/","text":"前言Java 入门第一篇。虽说 Java 里的骨子里流淌着的是 OOP 的思想，但入门这部分主要涉及变量类型，数据存储，初始化和析构等方面的内容，这其实是每个程序语言的基础知识。为了与后面的高级主题区别，所以我将这一部分称作 【面向过程】（其实叫做【入门过程】也未尝不可(/≧▽≦)/）。 正文java 的数值基本类型全是有符号的。 java 中每一个基本类型都对应这一个包装器类型。 java的基本类型存储在栈上，其他类型存储在堆上面。 java禁止内层作用域屏蔽外层作用域。例如下列代码C/C++合法，而java不合法123456&#123; int x = 0; &#123; int x = 1; &#125;&#125; 使用未初始化的基本类型变量会编译报错，基本类型变量作为累的成员时会默认初始化。Java 杜绝了对象的未初始化现象。 static 关键字：单一特性，类特性 java.lang 是默认导入到每个java文件的。 java 的注释分为两种： 普通注释：// 和 /* */ 文档注释: /** */，可以嵌入HTML或文档标签，自动生成复杂的文档页面 基本类型，字符串，数组，包装类型，自定义类型数据的比较，赋值，参数传递问题 java 的三种位移操作符：左移操作符&lt;&lt;，右移操作符&gt;&gt;，无符号右移操作符&gt;&gt;&gt;。 窄化转换必须要显示转换，而扩展转换则不必。基本类型扩展转换表，见书p81。 java 中的执行流控制语句中引入了 foreach 语法和多重跳出规则。 构造函数虽然不是 static 成员函数，但是它的行为确实是 static 函数的行为。 使用不同类型的参数或者是不同个数的参数可以达到函数重载的目的。函数重载不依赖于函数返回值。 在处理构造函数方面，java 与 C++ 是基本一致的。基本一致体现在 Java 中的 class 里至少有一个构造函数（手写或者自动生成）；C++ 中如果一个没有手写构造函数的 class 没有被实例化，编译器是不会自动生成默认构造函数的。 Java 可以在构造函数中调用构造函数，目的是简化构造函数代码。这跟 C++11 的某个特性很想，记不起来了(⊙v⊙)。 Java 的一大卖点就是自动垃圾回收机制，高深的算法理论和设计机制就留给后面的章节再看吧。finalize() 函数也没有看懂。 class 数据初始化顺序： static 成员数据自动初始化（按顺序来） non-static 成员数据自动初始化 构造函数 最好不要在同一个函数用同样的可变参数重载多次。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jihongyu.github.io/tags/Java/"},{"name":"入门","slug":"入门","permalink":"https://jihongyu.github.io/tags/入门/"}]}]